# nanobot 仓库分析过程审阅（系统分析师 / Linus 视角）

目标：对“如何分析一个工程仓库”这件事本身做复盘与改进，而不是复述 nanobot 架构结论。  
适用对象：需要把分析结果用于后续改造/扩展/安全评估/工程化落地的人。

## 1. 总评（高维度）

这次分析流程的长处是“先收敛问题空间，再下钻关键路径”：
- 先用结构（目录树/入口点/依赖）锁定系统边界，再用极少量关键文件确认主数据流（AgentLoop、ContextBuilder、bus、channels）。
- 通过并行拆分主题（agent core / tools & skills / channels & bus / whatsapp bridge / ops）减少了线性探索成本。
- 输出既有给人看的 Markdown，也有机器可消费的 JSON（PLAN / SUMMARY），这点工程化价值高：可持续迭代、可自动比较、可被下游工具消费。

但从“Linus / 系统分析师”角度，仍有几类风险点与可改进点：
- **证据链一致性**：分析输出必须“只基于当前仓库的可验证事实”。任何跨仓库内容混入都会污染结论可信度（典型来源：并行 agent 的上下文漂移、Web 搜索引用不落地到本地源码）。
- **信任边界未前置**：分析如果要指导后续落地，必须在一开始声明“系统的安全/信任边界与威胁模型”，否则会把功能设计与安全设计混在一起，后续返工成本高。
- **关键不变量（invariants）提取不足**：例如“消息路由键设计”“工具调用格式”“workspace 限制策略”等属于体系级不变量，应单独抽为可复用规则；否则报告变成“描述性文本”，难以指导重构。

## 2. 对本次分析指令与过程的评论（挑剔版）

### 2.1 做得对的地方（值得复用）

- **先做结构索引，再做局部深读**：目录树 + 入口点 + 最大文件列表能快速判断“代码密度在何处”，避免被 README 或 demos 带偏。
- **最少关键文件原则**：锁定 5~10 个“定义系统行为”的文件（本仓库就是 `agent/loop.py`、`agent/context.py`、`channels/*`、`bus/*`、`tools/*`），其余文件先视为可替换实现细节。
- **并行拆分主题**：把“agent 回路”“工具/技能”“通道/总线”“bridge”“运维安全”拆开，让每个子任务都能独立完成，减少串行等待。
- **产物可持续**：把分析结果落到 `doc/nanobot/`，并提供索引，满足“以后再看/他人接手”。

### 2.2 该更强硬的地方（Linus 视角：不讲情面）

- **路径与语料的强约束**  
  任何子任务的阅读范围都应该强制限定在：
  - `ROOT=/Users/litianyi/Documents/__secondlife/__project/myr2d2/thirdparty/mynanobot`
  - 只允许引用 `ROOT` 下的文件链接  
  否则并行 agent 很容易在相似项目/历史记忆里“顺手引用”，造成污染。

- **把“结论”与“证据”拆开**  
  每条结论都应该能追溯到：
  - 文件 + 行范围（或至少文件）  
  - 一个最小可复现步骤（例如：某字段如何在运行时被拼成 session_key）  
  这样后续改造时可以稳定定位不变量。

- **明确非目标（Non-goals）**  
  如果当时的目标只是“架构扫描”，就不该混入“如何补测试/如何改 Dockerfile”的建议；相反，如果目标是“为生产落地”，就必须把威胁模型与权限模型放第一章。

- **安全审计需要更体系化**  
  指出潜在风险（如 SSRF、路径前缀判断）只是第一步；更高维的做法是：
  - 列出资产（keys / workspace / chat history / bridge auth）
  - 列出攻击面（web_fetch / exec / filesystem / inbound channels）
  - 列出控制点（allowFrom / restrict_to_workspace / timeouts）
  - 给出“优先级排序 + 最小修复集”

## 3. 后续分析工程的建议（可复用方法论）

### 3.1 三层输出法：结构 / 行为 / 风险

对任何工程仓库，建议按固定的三层输出：

1) **结构层（Structure）**  
入口点、模块边界、依赖、持久化位置、跨进程/跨线程点。

2) **行为层（Behavior）**  
关键链路的“事件/状态机”：输入→处理→输出；关键不变量；失败/重试/超时策略。

3) **风险层（Risk）**  
信任边界、攻击面、资源上限、数据合规、可观测性缺口、测试缺口。

这样做的价值：后续无论你要“扩展功能”还是“上线生产”，都能从同一套坐标系出发讨论，不会各说各话。

### 3.2 Linus 风格的“抓主线”问题清单

对一个陌生仓库，优先回答这 10 个问题（顺序就是优先级）：

1. 入口点是什么？（CLI / daemon / library / service）
2. 主循环在哪里？（event loop / scheduler / request handler）
3. 系统的输入/输出契约是什么？（消息结构、API、协议）
4. 状态在哪里？（内存、文件、DB、远端）
5. 不变量是什么？（路由键、ID 生成、格式、时序假设）
6. 并发模型是什么？（单线程、async、多进程、队列）
7. 失败如何处理？（重试、幂等、超时、降级）
8. 权限/信任边界在哪里？（allowlist、sandbox、路径限制）
9. 观测与调试抓手？（日志、trace、指标）
10. 测试覆盖到哪？（单测/集成/e2e/契约测试）

如果在 30 分钟内回答不了 1~5，说明你还在“阅读文件”，不算“理解系统”。

## 4. Prompt（提示词）改进建议与模板

你这次的 subagent 拆分是对的，但 prompt 需要更“工程化”，以避免污染与保证可复现。

### 4.1 Owner（总控）Prompt：强约束版

建议把总控 prompt 固定为可复用模板（把变量填进去即可）：

```
你是系统分析师。目标：在 60~90 分钟内产出“结构/行为/风险”三层报告，并落盘到 doc/<project>/。

硬约束：
1) 只允许使用本地仓库 ROOT=<ABS_PATH> 下的文件作为证据；禁止引用 ROOT 外内容。
2) 每条关键结论必须附带文件链接（至少到文件级，优先到行范围）。
3) 先输出结构层，再输出行为层，最后输出风险层；避免在结构层混入改造建议。
4) 输出必须包含：INDEX.md（索引）、SUMMARY.json（机器可读摘要）。

软约束：
- 最少阅读原则：优先目录树/入口点/核心循环文件；避免全量阅读。
- 并发策略：拆 5~7 个独立子主题并行分析。
```

### 4.2 Subagent Prompt：防上下文漂移版（关键）

每个子 agent 都应有“范围护栏 + 交付格式”：

```
任务：分析 <topic>。
仓库根目录：ROOT=<ABS_PATH>。只允许读取 ROOT 内文件；禁止引用任何其他仓库/互联网内容作为结论依据。

交付物（必须）：
1) 150~300 字摘要（结论先行）
2) 5~12 条要点（每条要点都带 file:/// 链接，优先到 #Lx-Ly）
3) 1 个风险/缺口列表（按 P0/P1/P2 分级）
4) 1 个“后续验证清单”（如果要跑程序/测例，列出最小命令集合；不需要真的执行）

不要做：
- 不要输出与 topic 无关的模块
- 不要引用 ROOT 外的文件/项目
- 不要为了凑内容而泛泛而谈
```

### 4.3 针对 nanobot 的“更好问题”Prompt（建议后续追加）

如果后续你要把分析用于工程改造（而不是仅架构学习），建议加这类问题驱动：

```
请从“可上线/可运营”的角度重审 nanobot：
1) 识别所有可写入磁盘的路径与数据类型（config、workspace、logs、session、bridge auth）
2) 列出网络出站入口（LLM provider、web_fetch、channel APIs）
3) 给出一个最小威胁模型（资产/攻击面/控制点）
4) 给出一个最小改造集：让它符合“最小权限 + 可审计 + 可限流”
每条结论必须提供源码定位链接。
```

## 5. 一个问题（只问一个）

你希望“后续分析工程”的重点更偏向哪一类输出？
- A. 架构学习（理解系统怎么跑）  
- B. 可扩展性（如何加 feature、加 channel、加 tool）  
- C. 生产落地（安全/权限/审计/可观测/测试）  

